<!DOCTYPE html><html lang="[&quot;zh&quot;,&quot;jp&quot;,&quot;default&quot;]"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Kubernetes 入门 （3） | Ryo's Blog</title><script>var config = {"hostname":"https://ryojerryyu.github.io/blog","root":"/blog/","preload":false,"path":""}</script><script src="//unpkg.com/mermaid@8.13.3/dist/mermaid.min.js"></script><script>mermaid.initialize({
  startOnLoad: false
  , theme: 'dark'
});</script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
  menuSettings: {
    zoom: "None"
  },
  showMathMenu: false,
  jax: ["input/TeX","output/CommonHTML"],
  extensions: ["tex2jax.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js"],
    equationNumbers: {
      autoNumber: "AMS"
    }
  },
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]]
  }
});</script><link rel="stylesheet" href="/blog/css/arknights.css"><link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.4.0/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/blog/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/blog/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.2.0"></head><body style="background-image:url(https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg);"><div id="cursor-container"><div id="cursor-outer"></div><div id="cursor-effect"></div></div><main><header><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><ol class="navContent"><li class="navItem search-header"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></li><li class="navItem"><a href="/blog/"><span class="navItemTitle">Home</span></a></li><li class="navItem"><a href="/blog/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav><div class="search-popup"><div id="search-result"></div></div></header><article><div id="post-bg"><div id="post-title"><h1>Kubernetes 入门 （3）</h1><div id="post-info"><span>First Post:<span class="control"><time datetime="2022-08-20T13:56:52.000Z" id="date"> 2022-08-20</time></span></span><br><span>Last Update:<span class="control"><time datetime="2022-08-30T16:36:02.000Z" id="updated"> 2022-08-31</time></span></span></div></div><hr><div id="post-content"><p>我们之前说的都是用于部署 Pod 的资源，我们接下来介绍与创建 Pod 不相关的资源：储存与网络。</p>
<h1 id="储存"><a href="#储存" class="headerlink" title="储存"></a>储存</h1><p>其实我们之前已经接触过储存相关的内容了：在讲 Stateful Set 时我们提过 Stateful Set 创建出来的 Pod 都会有相互独立的储存；而讲 Daemon Set 时我们提到 K8s 推荐只在 Daemon Set 的 Pod 中访问宿主机磁盘。但独立的储存具体指什么？除了访问宿主机磁盘以外还有什么其他的储存？</p>
<p>在 Docker 中，我们可以把宿主机磁盘上的一个路径作为一个 Volume 来给容器绑定，或者直接使用 Docker Engine 管理的 Volume 来提供持久化存储或是容器间共享文件。在 K8s 里面也沿用了 Volume 这个概念，可以通过 Mount 绑定到容器内的路径，并通过实现 CSI 的各种引擎来提供更多样的存储。</p>
<blockquote>
<p>CSI: Container Storage Interface ，容器储存接口标准，是 K8s 提出的一种规范。不管是哪种储存引擎，只要编写一个对应的插件实现 CSI ，都可以在 K8s 中使用。</p>
</blockquote>
<h3 id="K8s-中使用-Volume-与可用的-Volume-类型"><a href="#K8s-中使用-Volume-与可用的-Volume-类型" class="headerlink" title="K8s 中使用 Volume 与可用的 Volume 类型"></a>K8s 中使用 Volume 与可用的 Volume 类型</h3><p>其实 K8s 中使用 Volume 的例子我们一开始就已经接触过了。还记得一开始介绍 Pod 时的 Nginx 例子吗？</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">simple-webapp</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">main-application</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>      <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">shared-logs</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/log/nginx</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">sidecar-container</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>      <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;sh&quot;</span>,<span class="hljs-string">&quot;-c&quot;</span>,<span class="hljs-string">&quot;while true; do cat /var/log/nginx/access.log; sleep 30; done&quot;</span>]<br>      <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">shared-logs</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/log/nginx</span><br>  <span class="hljs-attr">volumes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">shared-logs</span><br>      <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br></code></pre></td></tr></table></figure>
<p>这个 Pod 描述中声明了一个种类为 <code>emptyDir</code> 的，名为 <code>shared-logs</code> 的 Volume ，然后 Pod 中的两个容器都分别 Mount 了这个 Volume 。</p>
<p>K8s 中默认提供了几种 Volume ，比如：</p>
<ul>
<li>emptyDir ：一个简单的空目录，一般用于储存临时数据或是 Pod 的容器之间共享数据。</li>
<li>hostPath ：绑定到节点宿主机文件系统上的路径，一般在 Daemon Set 中使用。</li>
<li>gitRepo ：这种 Volume 其实相当于 emptyDir ，不过在 Pod 启动时会从 Git 仓库 clone 一份内容作为默认数据。</li>
<li>configMap 、 secret ：一般用于配置文件加载，需要与 configMap 、 secret 这两种资源一同使用。会将 configMap 、 secret 中对应的内容拷贝一份作为 Volume 绑到容器。（下一节中会展开讨论）</li>
<li>nfs 、 glusterfs 、 ……：可以通过各种网络存储协议直接挂载一个网络存储</li>
<li>(deprecated!) gcePersistentDisk 、 awsElasticBlockStore ……：可以调用各个云平台的 API ，创建一个块储存硬件挂载到宿主机上，再将那个硬件挂载到容器中。</li>
<li>persistentVolumeClaim ：持久卷声明，用于把实际储存方式抽象化，使得 Pod 不需要关心具体的储存类型。这种类型会在下面详细介绍。</li>
</ul>
<p>我们可以注意到， Volume 的声明是 Pod 的一个属性，而不是一种单独的资源。 Volume 是 Pod 的一部分，因此不同的 Pod 之间永远不可能共享同一个 Volume 。</p>
<blockquote>
<p>但是 Volume 所指向的位置可以相同，比如 HostPath 类型的 Volume 就可以两个 Pod 可以绑定到宿主机上同一个路径，因此 Volume 里的数据还是能通过一定方式在 Pod 间共享。但当然 K8s 不推荐这么做。</p>
</blockquote>
<p>另外，由于 Volume 是 Pod 的一部分， Volume 的生命周期也是跟随 Pod 的，当一个 Pod 被销毁时， Volume 也会被销毁，因此最主要还是用于 Pod 内容器间的文件共享。如果需要持久化储存，需要使用 Persistent Volume 。</p>
<blockquote>
<p>Volume 会被销毁不代表 Volume 指向的内容会被销毁。比如 hostPath 、 NFS 等类型 Volume 中的内容就会继续保留在宿主机或是 NAS 上。下面提到的 Presistent Volume Claim 也是，拥有 <code>persistentVolumeClaim</code> 类型 Volume 的 Pod 被删除后对应的 PVC 不一定会被删除。</p>
</blockquote>
<h3 id="Presistent-Volume-、-Presistent-Volume-Claim-、-Storage-Class"><a href="#Presistent-Volume-、-Presistent-Volume-Claim-、-Storage-Class" class="headerlink" title="Presistent Volume 、 Presistent Volume Claim 、 Storage Class"></a>Presistent Volume 、 Presistent Volume Claim 、 Storage Class</h3><p>如果需要在 Pod 声明中直接指定 NFS 、 awsElasticBlockStore 之类的信息，就需要应用的开发人员对真实可用的储存结构有所理解，违背了 K8s 的理念。因此 K8s 就弄出了小标题中的三种资源来将储存抽象化。</p>
<p>一个 Persistent Volume (PV) 对应云平台提供的一个块存储，或是 NAS 上的一个路径。可以简单地理解为 <strong>PV 直接描述了一块可用的物理存储</strong> 。因为 PV 直接对应到硬件，因此 PV 跟节点一样，是名称空间无关的。</p>
<p>而一个 <strong>Persistent Volume Claim (PVC) 则是描述了怎样去使用储存</strong> ：使用多少空间、只读还是读写等。一个 PVC 被创建后会且只会对应到一个 PV 。 PVC 从属于一个名称空间，并能被该名称空间下的 Pod 指定为一个 Volume 。</p>
<p>PV 与 PVC 这两种抽象是很必要的。试想一下用自己的物理机搭建一个 K8s 集群的场景。你会提前给物理机插上许多个储存硬件，这时你就需要用 PV 来描述这些硬件，之后才能在 K8s 里利用这些硬件的储存。而实际将应用部署到 K8s 中时，你才需要用 PVC 来描述 Pod 中需要怎么样的储存卷，然后 K8s 就会自动挑一个合适 PV 给这个 PVC 绑定上。这样实际部署应用的时候就不用再特意跑去机房给物理机插硬件了。</p>
<p>但是现在都云原生时代了，各供应商都有提供 API 可以直接创建一个块储存，还要想办法提前准备 PV 实在是太蠢了。于是便需要 Storage Class 这种资源。</p>
<p>使用 Storage Class 前需要先安装各种云供应商提供的插件（当然使用云服务提供的 K8s 的话一般已经准备好了），然后再创建一个 Storage Class 类型的资源（当然一般也已经准备好了）。下面是 AWS 上的 EKS 服务中默认自带的 Storage Class ：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">storage.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StorageClass</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-attr">storageclass.kubernetes.io/is-default-class:</span> <span class="hljs-string">&quot;true&quot;</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">gp2</span><br><span class="hljs-attr">provisioner:</span> <span class="hljs-string">kubernetes.io/aws-ebs</span><br><span class="hljs-attr">parameters:</span><br>  <span class="hljs-attr">fsType:</span> <span class="hljs-string">ext4</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">gp2</span><br><span class="hljs-comment"># 当 PVC 被删除时会同时删除 PV</span><br><span class="hljs-attr">reclaimPolicy:</span> <span class="hljs-string">Delete</span><br><span class="hljs-comment"># 只有当 PVC 被绑定为一个 Pod 的 Volume 时才会创建一个 PV</span><br><span class="hljs-attr">volumeBindingMode:</span> <span class="hljs-string">WaitForFirstConsumer</span><br></code></pre></td></tr></table></figure>
<p>可以看到 EKS 自带的 gp2 提供了一些默认的选项，我们也可以类似地去定义自己的 Storage Class 。有了 gp2 这个 Storage Class ，我们创建一个 PVC 后 K8s 就会调用 AWS 的 API ，创建一个块储存接到我们的节点上，然后 K8s 再自动创建一个 PV 并绑定到 PVC 上。</p>
<p>例如，我们部署 Kafka 时会创建一个这样的 PVC ：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">data-kafka-0</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">accessModes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-attr">requests:</span><br>      <span class="hljs-attr">storage:</span> <span class="hljs-string">10Gi</span><br>  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">gp2</span><br></code></pre></td></tr></table></figure>
<p>K8s 就会自动为我们创建出一个对应的 PV ：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># `pvc-` 开头这个是 AWS 自动给我们起的名字。它虽然是 `pvc-` 开头，但他其实是一个 PV 。</span><br>NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                STORAGECLASS   REASON   AGE<br>pvc-3614c15f-5697-4d66-a13c-6ddf7eb89998   10Gi       RWO            Delete           Bound    kafka/data-kafka-0   gp2                     152d<br></code></pre></td></tr></table></figure>
<p>要是打开 AWS Console 还会发现， K8s 调用了 AWS 的 API ，自动为我们创建了一个 EBS 块储存并绑定到了我们对应的宿主机上。</p>
<p>可以用下面这张图来表示 Pod 中的 Volume 、 PVC 、 PV 之间的关系：</p>
<pre class="mermaid">flowchart TD

subgraph Pod[Pod: Kafka-0]
subgraph Container[Container: docker.io/bitnami/kafka:3.1.0]
vm[VolumeMount: /bitnami/kafka]
end
volume[(Volume: data)]
vm --> volume
end

pvc[pvc: data-kafka-0]
pv[pv: pvc-3614c15f-5697-4d66-a13c-6ddf7eb89998]
ebs[ebs: AWS 为我们创建的块储存硬件]

volume --> pvc
pvc --> pv
pv --> ebs</pre>

<p>而 Storage Class 在上图中则负责读取我们提交的 PVC ，然后创建 PV 与 EBS 。</p>
<h3 id="再说回-Stateful-Set"><a href="#再说回-Stateful-Set" class="headerlink" title="再说回 Stateful Set"></a>再说回 Stateful Set</h3><p>之前我们提到 Stateful Set 时说到 Stateful Set 创建的 Pod 拥有固定的储存，到底是什么意思呢？跟 Deployment 的储存又有什么区别呢？</p>
<p>我们先来看看，如果要给 Deployment 创建出来的 Pod 挂载 PVC 需要怎么做。下面是一个部署 Nginx 的 Deployment 清单，其中 html 目录下的静态文件存放在 NFS 里，通过 PVC 挂载到 Pod 中：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 这里省略了 Service 相关的内容</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-dpl-with-nfs-pvc</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br>        <span class="hljs-attr">volumeMounts:</span> <span class="hljs-comment">#挂载容器中的目录到 pvc nfs 中的目录</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">www</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/nginx/html</span><br>      <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">www</span><br>        <span class="hljs-attr">persistentVolumeClaim:</span> <span class="hljs-comment">#指定pvc</span><br>          <span class="hljs-attr">claimName:</span> <span class="hljs-string">nfs-pvc-for-nginx</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-pvc-for-nginx</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">storageclassname:</span> <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment"># 指定使用现有 PV ，不使用 StorageClass 创建 PV</span><br>  <span class="hljs-attr">accessModes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteMany</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-attr">requests:</span><br>      <span class="hljs-attr">storage:</span> <span class="hljs-string">1Gi</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment"># 这个例子中需要挂载 NFS 上的特定路径，所以手动定义了一个 PV</span><br><span class="hljs-comment"># 一般情况下我们不会手动创建 PV，而是使用 StorageClass 自动创建</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolume</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-pv-for-nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">capacity:</span> <br>    <span class="hljs-attr">storage:</span> <span class="hljs-string">1Gi</span><br>  <span class="hljs-attr">accessModes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteMany</span><br>  <span class="hljs-attr">persistentVolumeReclaimPolicy:</span> <span class="hljs-string">Retain</span><br>  <span class="hljs-attr">nfs:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/nfs/sharefolder/nginx</span><br>    <span class="hljs-attr">server:</span> <span class="hljs-number">81.70</span><span class="hljs-number">.4</span><span class="hljs-number">.171</span><br></code></pre></td></tr></table></figure>
<p>这份清单我们主要关注前两个资源，我们可以看到除了一个 Deployment 资源以外我们还单独定义了一个 PVC 资源。然后在 Deployment 的 Pod 模板中声明并绑定了这个 PVC 。</p>
<p>可这样 apply 了之后会发生什么情况呢？因为我们只声明了一份 PVC ，当然我们只会拥有一个 PVC 资源。但这个 Deployment 的副本数是 3 ，因此我们会有 3 个相同的 Pod 去绑定同一个 PVC 。也就是最终会在 3 个容器里访问同一个 NFS 的同一个目录。如果我们在其中一个容器里对这个目录作修改，也会影响到另外两个容器。</p>
<blockquote>
<p>注：这一现象不一定在任何情况下都适用。比如 AWS 的 EBS 卷只支持单个 AZ 内的绑定。如果 Pod 因为 Node Affinity 等设定被部署到了多个区，没法绑定同一个 EBS 卷，就会在 Scedule 的阶段报错。</p>
</blockquote>
<p>很多时候我们都不希望多个 Pod 绑定到同一 PVC 。比如我们部署一个 DB 集群的时候，如果好不容易部署出来的多个实例居然用的是同一份储存，就会显得很呆。 Stateful Set 就是为了解决这种情况，会为其管理下的每个 Pod 都部署一个专用的 PVC 。</p>
<p>下面是给 Stateful Set 创建出来的 Pod 挂载 PVC 的一份清单：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 这里省略了 Service 相关的内容</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StatefulSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">serviceName:</span> <span class="hljs-string">&quot;nginx&quot;</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">k8s.gcr.io/nginx-slim:0.8</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">www</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/nginx/html</span><br>  <span class="hljs-attr">volumeClaimTemplates:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">www</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">accessModes:</span> [ <span class="hljs-string">&quot;ReadWriteOnce&quot;</span> ]<br>      <span class="hljs-attr">resources:</span><br>        <span class="hljs-attr">requests:</span><br>          <span class="hljs-attr">storage:</span> <span class="hljs-string">1Gi</span><br></code></pre></td></tr></table></figure>
<p>我们可以看到，部署 Stateful Set 时我们不能另外单独定义一份 PVC 了，只能作为 Stateful Set 定义的一部分，在 volumeClaimTemplates 字段中定义 PVC 的模板。这样一来， Stateful Set 会根据这个模板，为每个 Pod 创建一个对应的 PVC ，并作为 Pod 的 Volume 绑定上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Stateful Set 创建出来的 Pod ，名字都是按顺序的</span><br>$ kubectl get pods -l app=nginx<br>NAME      READY     STATUS    RESTARTS   AGE<br>web-0     1/1       Running   0          1m<br>web-1     1/1       Running   0          1m<br><br><span class="hljs-comment"># Stateful Set 创建出来的 PVC ，名字与 Pod 的名字一一对应</span><br>$ kubectl get pvc -l app=nginx<br>NAME        STATUS    VOLUME                                     CAPACITY   ACCESSMODES   AGE<br>www-web-0   Bound     pvc-15c268c7-b507-11e6-932f-42010a800002   1Gi        RWO           48s<br>www-web-1   Bound     pvc-15c79307-b507-11e6-932f-42010a800002   1Gi        RWO           48s<br></code></pre></td></tr></table></figure>
<p>这样， Stateful Set 的多个 Pod 就会拥有自己的储存，不会相互打架了。另外，如果我们事先定义了 StorageClass ，还能根据 Stateful Set 的副本数动态配置 PV 。</p>
<h3 id="ConfigMap-与-Secret-挂载作为特殊的卷"><a href="#ConfigMap-与-Secret-挂载作为特殊的卷" class="headerlink" title="ConfigMap 与 Secret 挂载作为特殊的卷"></a>ConfigMap 与 Secret 挂载作为特殊的卷</h3><p>有时候我们需要使用配置文件来配置应用（比如 Nginx 的配置文件），而且我们有时候会需要不重启 Pod 就热更新配置。如果用 PVC 来加载配置文件略微麻烦，这时候可以使用 Config Map 。</p>
<p>下面是 K8s 官网上 Config Map 的一个例子：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">game-demo</span><br><span class="hljs-attr">data:</span><br>  <span class="hljs-comment"># 一个 Key 可以对应一个值</span><br>  <span class="hljs-attr">player_initial_lives:</span> <span class="hljs-string">&quot;3&quot;</span><br>  <span class="hljs-attr">ui_properties_file_name:</span> <span class="hljs-string">&quot;user-interface.properties&quot;</span><br><br>  <span class="hljs-comment"># 一个 Key 也可以对应一个文件的内容</span><br>  <span class="hljs-attr">game.properties:</span> <span class="hljs-string">|</span><br><span class="hljs-string">    enemy.types=aliens,monsters</span><br><span class="hljs-string">    player.maximum-lives=5    </span><br><span class="hljs-string"></span>  <span class="hljs-attr">user-interface.properties:</span> <span class="hljs-string">|</span><br><span class="hljs-string">    color.good=purple</span><br><span class="hljs-string">    color.bad=yellow</span><br><span class="hljs-string">    allow.textmode=true    </span><br><span class="hljs-string"></span><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">configmap-demo-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">demo</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">alpine</span><br>      <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;sleep&quot;</span>, <span class="hljs-string">&quot;3600&quot;</span>]<br>      <span class="hljs-attr">env:</span><br>        <span class="hljs-comment"># ConfigMap 的 Key 可以作为环境变量引用</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">PLAYER_INITIAL_LIVES</span><br>          <span class="hljs-attr">valueFrom:</span><br>            <span class="hljs-attr">configMapKeyRef:</span><br>              <span class="hljs-attr">name:</span> <span class="hljs-string">game-demo</span>           <span class="hljs-comment"># 从这个 Config Map 里</span><br>              <span class="hljs-attr">key:</span> <span class="hljs-string">player_initial_lives</span> <span class="hljs-comment"># 拿到这个 key 的值</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">UI_PROPERTIES_FILE_NAME</span><br>          <span class="hljs-attr">valueFrom:</span><br>            <span class="hljs-attr">configMapKeyRef:</span><br>              <span class="hljs-attr">name:</span> <span class="hljs-string">game-demo</span><br>              <span class="hljs-attr">key:</span> <span class="hljs-string">ui_properties_file_name</span><br>      <span class="hljs-attr">volumeMounts:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config</span><br>        <span class="hljs-attr">mountPath:</span> <span class="hljs-string">&quot;/config&quot;</span><br>        <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">volumes:</span><br>    <span class="hljs-comment"># 定义 Pod 的 Volume ，种类为 configMap</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config</span><br>      <span class="hljs-attr">configMap:</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">game-demo</span> <span class="hljs-comment"># ConfigMap的名字</span><br>        <span class="hljs-comment"># 需要作为文件放入 Volume 的 Key</span><br>        <span class="hljs-attr">items:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;game.properties&quot;</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;game.properties&quot;</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;user-interface.properties&quot;</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;user-interface.properties&quot;</span><br></code></pre></td></tr></table></figure>
<p>我们可以看到 ConfigMap 里的 Key 可以作为文件或是环境变量加载到 Pod 中。另外，作为环境变量加载后其实还能作为命令行参数传入应用，实现各种配置方式。如果修改 Config map 的内容，也可以自动更新 Pod 中的文件。</p>
<p>然而， Config Map 的热更新有一些不太灵活的地方：</p>
<ol>
<li>作为环境变量加载的 Config Map 数据不会被热更新。想要更新这一部分数据需要重启 Pod。（当然，命令行参数也不能热更新）</li>
<li>由于 Kubelet 会先将 Config Map 内容加载到本地作为缓存，因此修改 Config Map 后新的内容不会第一时间加载到 Pod 中。而且在旧版本的 K8s 中， Config Map 被更新直到缓存被刷新的时间间隔还会很长，新版本的 K8s 这一部分有了优化，可以设定刷新时间，但会导致 API Server 的负担加重。（这其实是一个 Known Issue ，被诟病多年： <a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/issues/22368">https://github.com/kubernetes/kubernetes/issues/22368</a> ）</li>
</ol>
<p>除 Config Map 以外， K8s 还提供了一种叫 Secret 的资源，用法和 Config Map 几乎一样。对比 Config Map ，Secret 有以下几个特点：</p>
<ol>
<li>在 Pod 里， Secret 只会被加载到内存中，而永远不会被写到磁盘上。</li>
<li>用 <code>kubectl get</code> 之类的命令显示的 Secret 内容会被用 base64 编码。（不过， well ，众所周知 base64 可不算是什么加密）</li>
<li>可以通过 K8s 的 Service Account 等 RBAC 相关的资源来控制 Secret 的访问权限。</li>
</ol>
<p>不过，由于 Secret 也是以明文的形式被存储在 K8s 的主节点中的，因此需要保证 K8s 主节点的安全。</p>
<blockquote>
<p><strong>Downward API 挂载作为特殊的卷</strong></p>
<p>还有另外一种叫 Downward API 的东西，可以作为 Volume 或是环境变量被加载到 Pod 中。有一些参数我们很难事先在 Manifest 中定义（ e.g. Deployment 生成的 Pod 的名字），因此可以通过 Downward API 来实现。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">test-volume-pod</span><br>    <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br>    <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">test-volume</span><br>        <span class="hljs-attr">node-env:</span> <span class="hljs-string">test</span><br><span class="hljs-attr">spec:</span><br>    <span class="hljs-attr">containers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">test-volume-pod-container</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">busybox:latest</span><br>      <span class="hljs-attr">env:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">POD_NAME</span> <span class="hljs-comment"># 将 Pod 的名字作为环境变量 POD_NAME 加载到 Pod 中</span><br>        <span class="hljs-attr">valueFrom:</span><br>          <span class="hljs-attr">fieldRef:</span><br>            <span class="hljs-attr">fieldPath:</span> <span class="hljs-string">metadata.name</span><br>      <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>]<br>      <span class="hljs-attr">args:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">while</span> <span class="hljs-literal">true</span><span class="hljs-string">;</span> <span class="hljs-string">do</span><br>          <span class="hljs-string">cat</span> <span class="hljs-string">/etc/podinfo/labels</span> <span class="hljs-string">|</span> <span class="hljs-string">echo;</span><br>          <span class="hljs-string">env</span> <span class="hljs-string">|</span> <span class="hljs-string">sort</span> <span class="hljs-string">|</span> <span class="hljs-string">echo;</span><br>          <span class="hljs-string">sleep</span> <span class="hljs-number">3600</span><span class="hljs-string">;</span><br>        <span class="hljs-string">done;</span><br>      <span class="hljs-attr">volumeMounts:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">podinfo</span><br>        <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/podinfo</span><br>    <span class="hljs-attr">volumes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">podinfo</span><br>      <span class="hljs-attr">downwardAPI:</span> <span class="hljs-comment"># Downward API 类型的卷</span><br>        <span class="hljs-attr">items:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;labels&quot;</span> <span class="hljs-comment"># 将 Pod 的标签作为  labels 文件挂载到 Pod 中</span><br>          <span class="hljs-attr">fieldRef:</span><br>            <span class="hljs-attr">fieldPath:</span> <span class="hljs-string">metadata.labels</span><br></code></pre></td></tr></table></figure>
</blockquote>
<p><a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div id="footer-link" style="right: calc(50% - 1px);order: 1;border-right: 1px solid #fe2;padding-left: unset;max-width: calc(50% - 4px);"><a href="/blog/2022/08/30/2022-08-31-introduction-for-k8s-4/">← Next Kubernetes 入门 （4）</a></div><div id="footer-link" style="left: 50%;order: 0;border-left: 1px solid #fe2;padding-right: unset;max-width: calc(50% - 5px);"><a href="/blog/2022/08/20/2022-08-20-introduction-for-k8s-2/">Kubernetes 入门 （2） Prev →</a></div></div></div></div><div id="bottom-btn"><a id="to-top" onClick="index.scrolltop();" title="to top" style="opacity: 0; display: none;">∧</a></div></article><div class="aside-box"><aside><div id="aside-top"><div id="about"><a href="/blog/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">Ryo Jerry Yu</a></h1><div id="description"><p>记录一些小事情。</p></div><!--if page.published === undefined--><section id="total"><a id="total-archives" href="/blog/archives"><span class="total-title">Archives Total:</span><span class="total-number">17</span></a><div id="total-tags"><span class="total-title">Tags:</span><span class="total-number">22</span></div><div id="total-categories"><span class="total-title">Categories:</span><span class="total-number">0</span></div></section></div><div id="aside-block"><div id="toc-div"><h1>INDEX</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%82%A8%E5%AD%98"><span class="toc-number">1.</span> <span class="toc-text">储存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#K8s-%E4%B8%AD%E4%BD%BF%E7%94%A8-Volume-%E4%B8%8E%E5%8F%AF%E7%94%A8%E7%9A%84-Volume-%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.0.1.</span> <span class="toc-text">K8s 中使用 Volume 与可用的 Volume 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Presistent-Volume-%E3%80%81-Presistent-Volume-Claim-%E3%80%81-Storage-Class"><span class="toc-number">1.0.2.</span> <span class="toc-text">Presistent Volume 、 Presistent Volume Claim 、 Storage Class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E8%AF%B4%E5%9B%9E-Stateful-Set"><span class="toc-number">1.0.3.</span> <span class="toc-text">再说回 Stateful Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConfigMap-%E4%B8%8E-Secret-%E6%8C%82%E8%BD%BD%E4%BD%9C%E4%B8%BA%E7%89%B9%E6%AE%8A%E7%9A%84%E5%8D%B7"><span class="toc-number">1.0.4.</span> <span class="toc-text">ConfigMap 与 Secret 挂载作为特殊的卷</span></a></li></ol></li></ol></li></ol></div></div></div><footer><nobr><span class="text-title">©</span><span class="text-content"></span></nobr><br><nobr><span class="text-title">ICP</span><span class="text-content"></span></nobr><br><text>published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></text><text> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight</a></text><wbr><text>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></text></footer></aside></div></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script>const reset=_=>{mermaid.init(undefined, ('.mermaid'));}</script><script src="//unpkg.com/@highlightjs/cdn-assets@11.4.0/highlight.min.js"></script><script src="/blog/js/arknights.js"></script><script>document.addEventListener("load",reset())</script></body></html>